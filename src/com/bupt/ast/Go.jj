/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Go.jj */
/*@egen*//**
*
*/
options {
  BUILD_PARSER=true;
  JAVA_UNICODE_ESCAPE = true;
  CACHE_TOKENS = true;
  STATIC = false;
  USER_CHAR_STREAM = true;

               
                 

                       

                          
  OUTPUT_DIRECTORY = "gcc";

                              
}

PARSER_BEGIN(Go)
package golang;
import com.bupt.ast.*;


public class Go/*@bgen(jjtree)*/implements GoTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTGoState jjtree = new JJTGoState();

/*@egen*/
  public static void main(String args []) throws ParseException
  {
    Go parser;
    if (args.length == 0)
    {
        System.out.println("Reading from standard input...");
        System.out.print("Enter enter some Golang :");
        parser = new Go(System.in);
    }
    else if (args.length == 1)
    {
        System.out.println("Go Parser:  Reading from file " + args [0] + " . . .");
        try
         {
             parser = new Go(new FileInputStream(args [0]), "UTF-8");
         }
        catch (java.io.FileNotFoundException e)
         {
             System.out.println("Go Parser:  File " + args [0] + " not found.");
            return;
         }
    }
    else {
        System.out.println("Go Parser:  Usage is one of:");
        System.out.println("         Go < inputfile");
        System.out.println("OR");
        System.out.println("         Go inputfile");
        return;
    }
    try
    {
         SimpleNode n = parser.Program();
         n.dump("");

         System.out.println("Go parser:  Go program parsed successfully.");
    }
    catch (ParseException e)
    {
         System.out.println(e.getMessage());
         System.out.println("Go parser:  Encountered errors during parse.");
    }

  }
}

PARSER_END(Go)


SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"

|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN : {
 <INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? | <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?>
|  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
|  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
|  <#OCTAL_LITERAL: "0" (["0"-"7"])*>
|  <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]>
|  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
|  <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
|  <STRING_LITERAL: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "\"">
}

TOKEN : /* OPERATORS */
{
  < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
}

TOKEN :
{
  < CONSTANT : (< DIGIT >)+ >
| < SEMICOLON: ";" >
| < COLON: ":" >
| < RB :"}" >
| < LB :"{" >
| < RP :")" >
| < LP :"(" >
| < EQL:"=" >
| < COMMA:"," >

}

TOKEN : {
  <FLOAT: "float">
| <VOID: "void">
| <INT: "int">
| <CHAR: "char">
| <VAR: "var">
| < BOOL :"bool" >
| <STRING: "string">
| < TRUE :"true">
| < FALSE :"false">
}

TOKEN : {
	<CONTINUE: "continue"> |
	<SWITCH: "switch"> |
	<RETURN: "return"> |
	<STRUCT: "struct"> |
	<STATIC: "static"> |
	<FUNC: "func" >  |
	<BREAK: "break"> |
	<CONST: "const"> |
	<DFLT: "default">|
	<ELSE: "else"> |
	<CASE: "case"> |
	<GOTO: "goto"> |
	<FOR: "for"> |
	<TYPE:"type">|
	<IF: "if"> |
	<DO: "do">
}

TOKEN : {
 <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
|  <#LETTER: ["$","A"-"Z","_","a"-"z"]>
|  <#DIGIT: ["0"-"9"]>
}

TOKEN: {
  < AND: "&&" >
}








int one_line() :
{/*@bgen(jjtree) one_line */
  ASTone_line jjtn000 = new ASTone_line(this, JJTONE_LINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) one_line */
 try {
/*@egen*/
 Statements()/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/  {
	return 0;
 }/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void sum() :
{/*@bgen(jjtree) sum */
  ASTsum jjtn000 = new ASTsum(this, JJTSUM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) sum */
  try {
/*@egen*/
  term()
  (
    (
      < PLUS >
    | < MINUS >
    )
    term()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void term() :
{/*@bgen(jjtree) term */
  ASTterm jjtn000 = new ASTterm(this, JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) term */
  try {
/*@egen*/
  unary()
  (
    (
      < MULTIPLY >
    | < DIVIDE >
    )
    unary()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void unary() :
{/*@bgen(jjtree) unary */
  ASTunary jjtn000 = new ASTunary(this, JJTUNARY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) unary */
  try {
/*@egen*/
  < MINUS > element()
| element()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void element() :
{/*@bgen(jjtree) element */
  ASTelement jjtn000 = new ASTelement(this, JJTELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) element */
  try {
/*@egen*/
  < CONSTANT >
| "(" sum() ")"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DeclarationStatement() :
{/*@bgen(jjtree) DeclarationStatement */
  ASTDeclarationStatement jjtn000 = new ASTDeclarationStatement(this, JJTDECLARATIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DeclarationStatement */
   try {
/*@egen*/
   (
     LOOKAHEAD(4) < VAR > < INT >    < IDENTIFIER >  Assignment() < INTEGER_LITERAL >
 | LOOKAHEAD(4) < VAR > < FLOAT >  < IDENTIFIER >  Assignment() < FLOATING_POINT_LITERAL >
 | LOOKAHEAD(4) < VAR > < STRING > < IDENTIFIER >  Assignment() < STRING_LITERAL >
 | LOOKAHEAD(4) < VAR > < CHAR >   < IDENTIFIER >  Assignment() < CHARACTER_LITERAL >
 | < VAR > type() <IDENTIFIER >
) <SEMICOLON >/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void type():
{/*@bgen(jjtree) type */
  ASTtype jjtn000 = new ASTtype(this, JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) type */
  try {
/*@egen*/
  < INT >
| < FLOAT >
| < STRING >
| < CHAR >
| < BOOL >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

void Assignment() : {/*@bgen(jjtree) Assignment */
  ASTAssignment jjtn000 = new ASTAssignment(this, JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Assignment */
        try {
/*@egen*/
	( "=" )/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AssignmentOperator() :{/*@bgen(jjtree) AssignmentOperator */
  ASTAssignmentOperator jjtn000 = new ASTAssignmentOperator(this, JJTASSIGNMENTOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) AssignmentOperator */
  try {
/*@egen*/
  ( "=" | "*=" | "/=" | "%=" | "+=" | "-=" )/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void OneOperandOperator() : {/*@bgen(jjtree) OneOperandOperator */
  ASTOneOperandOperator jjtn000 = new ASTOneOperandOperator(this, JJTONEOPERANDOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) OneOperandOperator */
  try {
/*@egen*/
  ( "++"|"--")/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

void IterationStatement() : {/*@bgen(jjtree) IterationStatement */
  ASTIterationStatement jjtn000 = new ASTIterationStatement(this, JJTITERATIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IterationStatement */
   try {
/*@egen*/
   < FOR > (LOOKAHEAD(2) Condition() |LOOKAHEAD(2) (SimpleStatement())? <SEMICOLON > (Condition())?    <SEMICOLON >(InCrement())? ) Block()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/

}
void SimpleStatement(): {/*@bgen(jjtree) SimpleStatement */
  ASTSimpleStatement jjtn000 = new ASTSimpleStatement(this, JJTSIMPLESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) SimpleStatement */
  try {
/*@egen*/
  < IDENTIFIER > <COLON > <EQL > <INTEGER_LITERAL >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ConditionalStatement() : {/*@bgen(jjtree) ConditionalStatement */
  ASTConditionalStatement jjtn000 = new ASTConditionalStatement(this, JJTCONDITIONALSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConditionalStatement */
  try {
/*@egen*/
  ( < IF >  (Condition())*  Block()
  ) (< ELSE > (ConditionalStatement()| Block()))?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Condition():{/*@bgen(jjtree) Condition */
  ASTCondition jjtn000 = new ASTCondition(this, JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Condition */
  try {
/*@egen*/
  (
    Operand() RelationOperations() Operand()
    )(<AND >)?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void RelationOperations():{/*@bgen(jjtree) RelationOperations */
  ASTRelationOperations jjtn000 = new ASTRelationOperations(this, JJTRELATIONOPERATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RelationOperations */
  try {
/*@egen*/
  ( "<" | ">" | "<=" | ">="  | "==" | "!=" )/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Block():{/*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(this, JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Block */
  try {
/*@egen*/
  < LB > (Statement())*    < RB >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}


void  AssignmentStatement(): {/*@bgen(jjtree) AssignmentStatement */
  ASTAssignmentStatement jjtn000 = new ASTAssignmentStatement(this, JJTASSIGNMENTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) AssignmentStatement */
  try {
/*@egen*/
  (
    < IDENTIFIER > AssignmentOperator() Operand() <SEMICOLON >
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void InCrement() :{/*@bgen(jjtree) InCrement */
  ASTInCrement jjtn000 = new ASTInCrement(this, JJTINCREMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) InCrement */
  try {
/*@egen*/
  < IDENTIFIER > OneOperandOperator() <SEMICOLON >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Operand(): {/*@bgen(jjtree) Operand */
  ASTOperand jjtn000 = new ASTOperand(this, JJTOPERAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Operand */
  try {
/*@egen*/
  < IDENTIFIER > | < CHARACTER_LITERAL >|<INTEGER_LITERAL >|<FLOATING_POINT_LITERAL >|<STRING_LITERAL > | <TRUE >|< FALSE >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}
void FunctionDeclaration() : {/*@bgen(jjtree) FunctionDeclaration */
  ASTFunctionDeclaration jjtn000 = new ASTFunctionDeclaration(this, JJTFUNCTIONDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) FunctionDeclaration */
  try {
/*@egen*/
  < FUNC > <IDENTIFIER > < LP > (Parameter())* < RP >  ReturnType() FunctionBody()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

void ReturnType(): {/*@bgen(jjtree) ReturnType */
  ASTReturnType jjtn000 = new ASTReturnType(this, JJTRETURNTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ReturnType */
  try {
/*@egen*/
  (
    < LP > (Parameter())+   < RP >
    )
  | (type())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void FunctionBody(): {/*@bgen(jjtree) FunctionBody */
  ASTFunctionBody jjtn000 = new ASTFunctionBody(this, JJTFUNCTIONBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) FunctionBody */
  try {
/*@egen*/
  < LB >
  (Statement())*

  ReturnStatement()
  < RB >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ReturnStatement(): {/*@bgen(jjtree) ReturnStatement */
  ASTReturnStatement jjtn000 = new ASTReturnStatement(this, JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ReturnStatement */
  try {
/*@egen*/
  < RETURN > (Operand())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Parameter (): {/*@bgen(jjtree) Parameter */
  ASTParameter jjtn000 = new ASTParameter(this, JJTPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Parameter */
  try {
/*@egen*/
  (< COMMA >)?(< IDENTIFIER >)? type()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void function(): {/*@bgen(jjtree) function */
  ASTfunction jjtn000 = new ASTfunction(this, JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) function */
  try {
/*@egen*/
  <IDENTIFIER > <LP >(functionParam())*<RP >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void functionParam() : {/*@bgen(jjtree) functionParam */
  ASTfunctionParam jjtn000 = new ASTfunctionParam(this, JJTFUNCTIONPARAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) functionParam */
  try {
/*@egen*/
  (< IDENTIFIER > |<COMMA >)/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SwitchStatement(): {/*@bgen(jjtree) SwitchStatement */
  ASTSwitchStatement jjtn000 = new ASTSwitchStatement(this, JJTSWITCHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) SwitchStatement */
  try {
/*@egen*/
  < SWITCH > (SwitchExpression())?  SwitchBody()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SwitchExpression(): {/*@bgen(jjtree) SwitchExpression */
  ASTSwitchExpression jjtn000 = new ASTSwitchExpression(this, JJTSWITCHEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) SwitchExpression */
  try {
/*@egen*/
  LOOKAHEAD(2)< IDENTIFIER >
| (< IDENTIFIER > <COLON > <EQL > function())/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

void SwitchBody(): {/*@bgen(jjtree) SwitchBody */
  ASTSwitchBody jjtn000 = new ASTSwitchBody(this, JJTSWITCHBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) SwitchBody */
try {
/*@egen*/
< LB >
  (
    (
      < CASE > (Case())* < COLON > Statement()
    )
  )*
  (
    < DFLT > <COLON > Statement()
  )?
 < RB >/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void Case(): {/*@bgen(jjtree) Case */
  ASTCase jjtn000 = new ASTCase(this, JJTCASE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Case */
    try {
/*@egen*/
    (Operand() | < COMMA >)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void StructDec(): {/*@bgen(jjtree) StructDec */
  ASTStructDec jjtn000 = new ASTStructDec(this, JJTSTRUCTDEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) StructDec */
  try {
/*@egen*/
  < STRUCT > < IDENTIFIER > < LB >  < RB >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void inStruct() : {/*@bgen(jjtree) inStruct */
  ASTinStruct jjtn000 = new ASTinStruct(this, JJTINSTRUCT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) inStruct */
  try {
/*@egen*/
  FunctionDeclaration()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}
/*
void inDec():{ }
{

}
*/


void funCall(): {/*@bgen(jjtree) funCall */
  ASTfunCall jjtn000 = new ASTfunCall(this, JJTFUNCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }

{/*@bgen(jjtree) funCall */
  try {
/*@egen*/
  < IDENTIFIER >  <LP > (Parameter() )* < RP >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void Statement():{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(this, JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
  try {
/*@egen*/
  DeclarationStatement()
|  StructDec()
| funCall()
| ConditionalStatement()
| IterationStatement()
|LOOKAHEAD(2) AssignmentStatement()
| SwitchStatement()
|LOOKAHEAD(2) InCrement()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Statements(): {/*@bgen(jjtree) Statements */
  ASTStatements jjtn000 = new ASTStatements(this, JJTSTATEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Statements */
  try {
/*@egen*/
  (
    Statement()
  )+/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

ASTProgram Program():
{/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(this, JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
  try {
/*@egen*/
  (
    SourceElements()
  )?
  < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SourceElements()       :
{}
{
  (
    SourceElement()
  )+
}

void SourceElement()       :
{}
{
  LOOKAHEAD(FunctionDeclaration())
  FunctionDeclaration()
| Statement()
}
